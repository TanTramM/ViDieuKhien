#include "driver.h"
#include "main.h" 
/* main.h contains HAL definitions and GPIO Labels (DIR_Pin, EN_Pin...) 
   generated by CubeMX. It is mandatory to include it. */

/* --- EXTERNAL HANDLES --- */
/* These handles are defined in main.c by CubeMX */
extern TIM_HandleTypeDef htim1; // Encoder Timer
extern TIM_HandleTypeDef htim4; // PWM Timer (Replaces old TIM12)

/* --- 1. INITIALIZATION FUNCTION --- */
/* Call this function once in main(), before the while(1) loop */
void Driver_Init_All(void) 
{
    /* A. Initialize DWT for microsecond delay 
       (STM32F411 does not have TIM6, so we use DWT Cycle Counter) */
    if (!(CoreDebug->DEMCR & CoreDebug_DEMCR_TRCENA_Msk)) {
        CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
        DWT->CYCCNT = 0;
        DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
    }

    /* B. Start Encoder Interface (TIM1) */
    HAL_TIM_Encoder_Start(&htim1, TIM_CHANNEL_ALL);

    /* C. Start PWM Generation (TIM4 Channel 1) */
    HAL_TIM_PWM_Start(&htim4, TIM_CHANNEL_1);
}

/* --- 2. MICROSECOND DELAY (Replaces TIM6) --- */
void delay_us(uint32_t us) 
{
    uint32_t start_tick = DWT->CYCCNT;
    
    /* SystemCoreClock for F411 is 96MHz -> 1 us = 96 ticks */
    uint32_t delay_ticks = us * (SystemCoreClock / 1000000);

    /* Wait until the required number of ticks has passed */
    while ((DWT->CYCCNT - start_tick) < delay_ticks);
}

/* --- 3. 0.1ms DELAY WRAPPER (Legacy Compatibility) --- */
/* Input: period = 10 means 1.0 ms */
void delay_01ms(uint16_t period) 
{
    /* Convert to microseconds: period * 100 us */
    delay_us(period * 100);
}

/* --- 4. READ ENCODER POSITION --- */
int32_t ENC0_GetPos(void) 
{
    static int32_t p = 0, p_pre = 0, dp = 0;
    static int32_t pulse_cur = 0;

    /* Get current counter value from TIM1 using HAL Macro */
    p = (int32_t)__HAL_TIM_GET_COUNTER(&htim1);

    dp = p - p_pre;

    /* Handle counter overflow/underflow (16-bit logic) 
       Assumes Period (ARR) is set to 65535 in CubeMX */
    if (dp > 32768)
        dp -= 65536;
    else if (dp < -32768)
        dp += 65536;

    p_pre = p;
    pulse_cur += dp;

    return pulse_cur;
}

/* --- 5. SET PWM FREQUENCY --- */
void PWM0_Set_Freq(uint32_t freq) 
{
    if (freq == 0) return;

    /* Calculate Period (ARR):
       - TIM4 Clock (APB1) = 96MHz.
       - Prescaler (PSC) set in CubeMX = 47 -> Timer Clock = 2MHz.
       - Formula: Period = (TimerClock / Freq) - 1 
    */
    uint32_t timer_clock = 2000000; 
    uint32_t period = (timer_clock / freq) - 1;

    /* Clamp to 16-bit maximum value (TIM4 is a 16-bit timer) */
    if (period > 0xFFFF) period = 0xFFFF;

    /* Update AutoReload Register (ARR) */
    __HAL_TIM_SET_AUTORELOAD(&htim4, period);
}

/* --- 6. SET PWM DUTY CYCLE & DIRECTION --- */
void PWM0_Set_Duty(int16_t d) 
{
    /* Saturate input between -1000 and 1000 */
    if (d < -1000) d = -1000;
    else if (d > 1000) d = 1000;

    /* Handle Direction and Enable Pins
       Using GPIO Labels "EN" and "DIR" defined in CubeMX
    */
    if (d == 0) {
        /* Disable PWM (High Impedance) */
        HAL_GPIO_WritePin(EN_GPIO_Port, EN_Pin, GPIO_PIN_SET); 
    }   
    else {
        /* Enable PWM */
        HAL_GPIO_WritePin(EN_GPIO_Port, EN_Pin, GPIO_PIN_RESET);

        if (d > 0) {
            /* Forward Direction (DIR = 0/Reset) */
            /* Note: Check your hardware if Logic 0 or 1 is Forward */
            HAL_GPIO_WritePin(DIR_GPIO_Port, DIR_Pin, GPIO_PIN_RESET);
        }
        else {
            /* Reverse Direction (DIR = 1/Set) */
            HAL_GPIO_WritePin(DIR_GPIO_Port, DIR_Pin, GPIO_PIN_SET);
            d = -d; /* Take absolute value for pulse calculation */
        }
    }

    /* Calculate Pulse width for Capture Compare Register (CCR1) */
    /* Formula: Pulse = (ARR + 1) * Duty / 1000 */
    uint32_t arr = __HAL_TIM_GET_AUTORELOAD(&htim4);
    uint32_t pulse = (arr + 1) * d / 1000;

    /* Update CCR1 register */
    __HAL_TIM_SET_COMPARE(&htim4, TIM_CHANNEL_1, pulse);
}